# -*- coding: utf-8 -*-
"""edge_function.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1h8m_sOQs1fa6Wy8MaTUu1AUTsFFpfZrj
"""

import numpy as np
from google.colab.patches import cv2_imshow
import cv2 as cv

# Funciones
def translate3d(vertex, dx, dy, dz):
    """Operación de traslación 3d"""
    T = np.array([[1,0,0,dx], [0,1,0,dy], [0,0,1,dz], [0,0,0,1]])
    res =  np.matmul(T, vertex.T) 
    return res.T

def draw_wireframe(im, vertices, edges):
    """Dibuja objeto definido por vertices y bordes"""
    # Normalizar coordenadas homogeneas
    v_h = np.array([ v[:-2]/v[-1] for v in vertices])
    for e in edges:
        cv.line(im, tuple(v_h[e[0]].astype(int)), tuple(v_h[e[1]].astype(int)), (255,0,15), 2)
    for v in v_h:
        cv.circle(im, tuple(v.astype(int)), 3, (255,0,255),-1)

def project2D(vertex, f=35, w=100, h=100):
    """Aplica una transformacion de proyeccion pinhole"""
    M = np.array([
        [1, 0, 0, 0],
        [0, 1, 0, 0],
        [0, 0, 1, 0],
        [0, 0, 1/f, 0]])
    return np.matmul(M, vertex.T).T

def edge_function(v0, v1, p):
    """Retorna True si punto esta al lado derecho, False lo contrario
    (p_x − v0_x )(v1_y − v0_y ) − (p_y − v0_y )(v1_x − v0_x )
    """
    return (p[0]-v0[0])*(v1[1]-v0[1]) - (p[1]-v0[1])*(v1[0]-v0[0]) > 0

def inside_outside(p, edges, vertices):
    """Edges of the triangle"""
    return edge_function(vertices[edges[0][0]], vertices[edges[1][1]], p) and \
    edge_function(vertices[edges[1][0]], vertices[edges[2][1]], p) and \
    edge_function(vertices[edges[2][0]], vertices[edges[0][1]], p)



def get_boundbox(vertices, edges):
    """Get the boundbox edges of the triangle
    (max_x, max_y, min_x, min_y)
    """
    e = set([v for e in edges for v in e])
    t = [vertices[i] for i in e]
    return ( max([t[0][0], t[1][0], t[2][0]]), max([t[0][1], t[1][1], t[2][1]]),\
     min([t[0][0], t[1][0], t[2][0]]), min([t[0][1], t[1][1], t[2][1]]))

def draw(im, faces, edges, vertices):
    # Normalizar coordenadas homogeneas
    v_h = np.array([ v[:-2]/v[-1] for v in vertices])
    for f in faces:
        face_edges = [edges[i] for i in f]
        max_x, max_y, min_x, min_y = get_boundbox(v_h, face_edges)
        for x in range(int(min_x), int(max_x)):
            for y in range(int(min_y), int(max_y)):
                if inside_outside((x,y), face_edges, v_h):
                    im[y,x] = (255,0,0)

# Cubo definido en su sistema coordenado
v = np.array([[200,200,0,1],[0,200,0,1],[0,0,0,1]])
edges = [(0,1),(1,2),(2,0)]
faces = [(0,1,2)]

# Posicionar cubo en el sistema coordenado de la camara
# Recordar que la camara esta mirando al eje positivo z
dz = 200
dy = 0
dx = 0
v_c = translate3d(v, dx, dy, dz)
# Parametros camara
f = 200 # Distancia focal
# Tamano imagen
w = 500
h = 500
# Proyectar 3D -> 2D
vp = project2D(v_c, f, w, h)
# trasladar al centro de la imagen
vp = translate3d(vp, w/2, h/2, 0)

# Dibujar y mostrar
im = np.zeros((h,w,3), np.uint8)
draw(im, faces, edges, vp)
# draw_wireframe(im, vp, edges)
cv2_imshow(im)

